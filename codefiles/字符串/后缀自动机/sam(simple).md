# sam学习笔记

[TOC]



##### 题目链接

[P3804 【模板】后缀自动机 (SAM)](https://www.luogu.com.cn/problem/P3804 ) 

##### 一顿分析

方便起见,先无视出现次数不为1的限制

答案是**次数乘以长度**的最大值,那就找出现**次数多**,**长度长**的子串

先想个暴力,$n^2$枚举所有子串,trie树或者map或者别的什么方法维护一下这个子串的出现次数.

于是便得到了一个$O(n^2)$的~~优秀~~做法,但是n有$10^6$,肯定会T

考虑一下如何优化

首先光枚举子串就有大问题,$O(n^2)$太慢了,所以不能枚举所有子串

然后分析一下有哪些子串是没有必要枚举的

显然,如果$S_1$比$S_2$要长,而且出现次数也不比$S_2$少,那就可以不用管$S_2$了,它肯定不会是答案

但是这个性质对于减少枚举次数来说似乎没有什么明显的帮助,尝试让$S_2$的定位再精确一点

假设$S_2$为$S_1$的子串且不为$S_1$本身,如果任意$S_2$的出现次数都与$S_1$相等(总不能比$S_1$少吧),那么就可以不枚举$S_1$的子串了

好像有点东西了,但这种情况似乎很少发生,试着找找更常见的性质...

子串的话两端都不确定,情况太多,很不方便判断,那么尝试一下把右端点固定住...

假设$S_2$为$S_1$的非空后缀且不为$S_1$本身,如果所有$S_2$的出现次数都与$S_1$相等,那么就可以不枚举$S_1$的后缀了

挺方便了,但这种情况还是很罕见,一次排除所有后缀似乎有点难,排除一部分试试...

为了方便,接下来给出一些简写

​		$|S|$:字符串$S$的长度

​		$n$:等价于$|S|$(有时为了方便)

​		$S[x]$:字符串$S$的第$x$个字符

​		$S[l..r]$:字符串$S$的第$l$个字符到第$r$个字符组成的子串

​		$Suf[l]$:等价于$S[l..|S|]$,即字符串$S$从$l$开始的后缀

​		$cnt(T)$:字符串$T$在字符串$S$中出现的次数

​		$cnt(l..r)$:字符串$S[l..r]$在字符串$S$中出现的次数

如果$cnt(l_1..r)=cnt(l_2..r)$且$l_1<l_2$

那么有$cnt(l_1..r)=cnt(l_1+1..r)=...=cnt(l_2..r)$

简单地说,如果$S_1$的某个后缀出现次数和$S_1$相等,那么这个后缀以及那些比它长的后缀出现次数都一样

好像很有道理的样子..	$S[l_1..r]$和$S[l_2..r]$似乎把夹在它们之间的其他后缀卡住了

既然这些串出现的次数都一样,那么只需要关注其中最长的串,因为其他更短的串不会是答案



这个性质已足够普遍且实用,那么可以开始考虑如何利用它来快速找到答案

首先,可以把所有的子串按照右端点和出现次数分成若干类(如果$S_2$为$S_1$的后缀且出现次数相等就在同一类中),每一类都选取其中最长的串作为代表元

(很多博客按照endpos集合分类,其实和这里的分类方式是等价的)

比如对于$S=abbb$,就可以分为$\{""\},\{a\},\{ab\},\{b\},\{abb\},\{bb\},\{abbb,bbb\}$一共七类

可以发现,分出的类数并不会太多,而且每个类中的子串一定是**连续**的后缀(这里把像$abbb,bbb$或者$cabb,abb,bb,b$这样的关系称作**连续**),它们的长度也是连续的,并构成一个公差为1的等差数列

我们只要维护每个类中的串的出现次数和最大长度,然后枚举一下就可以统计出答案了

还是$abbb$,还是分为$\{""\},\{a\},\{ab\},\{b\},\{abb\},\{bb\},\{abbb,bbb\}$一共7类

出现次数分别为$无穷,1,1,3,1,2,1$

最长长度分别为	$0,1,2,1,3,2,4$

枚举一下,答案为4	(取$bb$或$abbb$)

那么现在的问题就只剩下如何维护这些类了



直接一大个字符串丢出来让我们维护就很离谱,先从简单的串做起吧.

$S=""$,分为$\{""\}$

$S="a"$,分为$\{""\},\{"a"\}$

$S="ab"$,分为$\{""\},\{"a"\},\{"ab","b"\}$

$S="abb"$,分为$\{""\},\{"a"\},\{"b"\},\{"ab"\},\{"abb","bb"\}$

$S="abbb"$,分为$\{""\},\{"a"\},\{"ab"\},\{"b"\},\{"abb"\},\{"bb"\},\{"abbb","bbb"\}$

每次在最后加一个字符,都会新增$|S|$个子串,它们是当前$S$的$|S|$个后缀

这$|S|$个后缀可能会导致原有的子串出现次数增加$1$或者$0$ 

显然,如果某个串的出现次数增加了,那么它的后缀的出现次数也会增加(新增的串为后缀关系)

现在对某个类以及在它里面的子串进行分析

如果有子串$T$由于出现次数增加要并入这个类,首先$T$肯定和其他子串为后缀关系且**连续**,而且这个类中有部分串的出现次数不变(本来次数就不相同,全体加1,次数还是不相同,不会合并)

​	如果$T$加入后是这个类中最长的串,那么因为$T$次数增加,它的后缀肯定也都会增加,与部分串的出现次数不变矛盾

​	如果$T$加入后是这个类中最短的串,那么因为它们原来不在同一个类中,$T$的次数一定比这个类中的串次数多(不管是之前还是之后),不需要合并

综上,合并这种情况不会发生(感觉可以在纸上画几组样例(建议画$abb...bbb$)方便理解)

如果这个类中的子串出现次数全体加$0$,那这个类对于本次维护来说就是局外类,不用管

如果这个类中的子串出现次数全体加$1$,因为次数还是都相同,而且没有其他子串并入,这个类也不会变

如果这个类中的子串出现次数有些加$0$,有些加$1$,那么由类的定义,它们现在不该在同一个类中了,需要分裂

显然是较短的一些串加$1$,较长的一些加$0$,那就把短的那些分裂出去吧..裂开之后,短的那些次数都相等,长的那些也一样,那么这个类就维护完了

没有其他情况了,维护结束

到这里,相信大家都已经有一个大概的思路了,接下来更具体的细节与代码实现应该也不用多说了

这里有一份[挺好的教程](https://oi-wiki.org/string/sam/) 

祝大家都能顺利AC,写出有各种各样风格的sam





最后一次编辑时间:2020.08.01


